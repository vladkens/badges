use rayon::iter::{IntoParallelIterator, ParallelIterator};
use rusttype::{point, Font, Scale};
use std::fs;

fn write_and_format(out_file: &str, code: &str) {
  let code = format!("// This file is generated by build.rs\n{}\n", code);
  fs::write(out_file, code).unwrap();
  let _ = std::process::Command::new("rustfmt")
    .arg("--")
    .arg(out_file)
    .status()
    .expect("Failed to run cargo fmt");
}

// MARK: Font Width

fn load_font() -> Font<'static> {
  let font_path = "/System/Library/Fonts/Supplemental/Verdana.ttf";
  let font_data = std::fs::read(font_path).expect("Failed to read font file");
  let font = Font::try_from_vec(font_data).expect("Failed to parse font data");
  font
}

// https://gitlab.redox-os.org/redox-os/rusttype/-/blob/d2b6874c/dev/examples/image.rs
// https://gitlab.redox-os.org/redox-os/rusttype/-/blob/d2b6874c/dev/examples/ascii.rs
fn calc_width(font: &Font, text: &str, size: f32) -> f32 {
  let scale = Scale { x: size * 1.25, y: size };
  let v_metrics = font.v_metrics(scale);
  let offset = point(0.0, v_metrics.ascent);
  let glyphs: Vec<_> = font.layout(text, scale, offset).collect();

  let width = glyphs
    .iter()
    .rev()
    .map(|g| g.position().x as f32 + g.unpositioned().h_metrics().advance_width)
    .next()
    .unwrap_or(0.0)
    .ceil();

  width
}

fn generate_width() {
  let font_size = 110.0;
  let font = load_font();

  let mut widths: Vec<f32> = vec![];
  for x in 0..2u32.pow(13) {
    if x <= 32 || x == 127 {
      widths.push(0.0);
    } else {
      let ch = char::from_u32(x).unwrap();
      let cw = calc_width(&font, &ch.to_string(), font_size);
      widths.push(cw);
    }
  }

  let code = format!("pub static WIDTHS: [f32; 8192] = {:?};", widths);
  write_and_format("src/width.rs", &code);
}

// MARK: Icons

fn get_files_of_kind(base_dir: &str, kind: &str) -> Vec<String> {
  fs::read_dir(base_dir)
    .unwrap()
    .filter_map(|x| match x {
      Err(_) => None,
      Ok(x) => {
        if !x.file_type().unwrap().is_file() {
          return None;
        }

        let path = x.path();
        if path.extension().unwrap_or_default() != kind {
          return None;
        }

        Some(path.to_str().unwrap().to_string())
      }
    })
    .collect()
}

fn generate_icons() {
  let icons: Vec<(String, String)> = get_files_of_kind("vendor/simple-icons/icons", "svg")
    .into_par_iter()
    .map(|x| {
      let name = x.split('/').last().unwrap().split('.').next().unwrap().to_string();
      let data = fs::read_to_string(x).unwrap();
      let data = data.split("<path d=\"").last().unwrap().split("\"").next().unwrap();
      (name, data.to_string())
    })
    .collect();

  let code = icons
    .iter()
    .map(|(name, data)| format!("  \"{}\" => r###\"{}\"###,", name, data))
    .collect::<Vec<String>>()
    .join("\n");

  let code = format!(
    "pub static ICONS: phf::Map<&'static str, &'static str> = phf::phf_map! {{\n\
    {code}\n\
    }};",
  );

  write_and_format("src/icons.rs", &code);
}

// MARK: Main

fn main() {
  println!("cargo::rerun-if-changed=build.rs");
  generate_width();
  generate_icons();
}
